import { PaymentMethod, PaymentStatus } from '@prisma/client';
import { NotFoundError, ValidationError, ForbiddenError } from '../errors/AppError';
import { IUnitOfWork } from '../repositories/interfaces/uow.interface';
import {
  CreatePaymentInput,
  PaymentResponse,
  PaymentSearchFilters,
  UpdatePaymentStatusInput,
  PaymentWebhookData,
} from '../types/payment.types';
import { PaginatedResponse } from '../types/common';
import redis from '../config/redis';
import { CacheUtil } from '../utils/cache.util';

export class PaymentService {
  constructor(private uow: IUnitOfWork) {}

  /**
   * T·∫°o payment cho ƒë∆°n h√†ng
   * @param orderId 
   * @param input 
   * @returns 
   */
  async createPayment(
    orderId: string,
    input: CreatePaymentInput
  ): Promise<PaymentResponse> {
    return this.uow.executeInTransaction(async (uow) => {
      // Ki·ªÉm tra order t·ªìn t·∫°i
      const order = await uow.orders.findById(orderId);
      if (!order) {
        throw new NotFoundError('ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i');
      }

      // Ki·ªÉm tra order ƒë√£ c√≥ payment ch∆∞a
      const existingPayment = await uow.payments.findByOrderId(orderId);
      if (existingPayment && existingPayment.status !== PaymentStatus.FAILED) {
        throw new ValidationError('ƒê∆°n h√†ng ƒë√£ c√≥ thanh to√°n');
      }

      // T√≠nh expiredAt (m·∫∑c ƒë·ªãnh 15 ph√∫t)
      const expiredAt = input.expiredAt || new Date(Date.now() + 15 * 60 * 1000);

      // T·∫°o payment
      const payment = await uow.payments.create({
        order: { connect: { id: orderId } },
        amount: input.amount,
        currency: input.currency || 'VND',
        method: input.method,
        status: PaymentStatus.PENDING,
        expiredAt,
        note: input.note || null,
      });

      // Invalidate cache
      await this.invalidatePaymentCache(undefined, orderId);

      return this.mapToPaymentResponse(payment);
    });
  }

  /**
   * L·∫•y th√¥ng tin payment theo ID
   * @param paymentId 
   * @param userId (optional) - ƒë·ªÉ check quy·ªÅn
   * @returns 
   */
  async getPaymentById(
    paymentId: string,
    userId?: string
  ): Promise<PaymentResponse> {
    // Ki·ªÉm tra cache tr∆∞·ªõc
    const cacheKey = CacheUtil.paymentById(paymentId);
    const cachedPayment = await redis.get(cacheKey);
    if (cachedPayment) {
      return JSON.parse(cachedPayment);
    }

    const payment = await this.uow.payments.findById(paymentId, {
      order: true,
      cashback: true,
    });

    if (!payment) {
      throw new NotFoundError('Thanh to√°n kh√¥ng t·ªìn t·∫°i');
    }

    // N·∫øu c√≥ userId, ki·ªÉm tra quy·ªÅn
    // üî• OPTIMIZED: Use already-fetched order instead of querying again
    if (userId && payment.orderId && payment.order) {
      // Ki·ªÉm tra c√≥ ph·∫£i ch·ªß ƒë∆°n h√†ng ho·∫∑c ch·ªß shop
      if (payment.order.userId !== userId) {
        const shop = await this.uow.shops.findById(payment.order.shopId);
        if (!shop || shop.ownerId !== userId) {
          throw new ForbiddenError('B·∫°n kh√¥ng c√≥ quy·ªÅn xem thanh to√°n n√†y');
        }
      }
    }

    const paymentResponse = this.mapToPaymentResponse(payment);

    // L∆∞u v√†o cache 30 ph√∫t
    await redis.set(cacheKey, JSON.stringify(paymentResponse), 1800);

    return paymentResponse;
  }

  /**
   * L·∫•y payment theo order ID
   * @param orderId 
   * @returns 
   */
  async getPaymentByOrderId(orderId: string): Promise<PaymentResponse | null> {
    // Ki·ªÉm tra cache tr∆∞·ªõc
    const cacheKey = CacheUtil.paymentByOrderId(orderId);
    const cachedPayment = await redis.get(cacheKey);
    if (cachedPayment) {
      return JSON.parse(cachedPayment);
    }

    const payment = await this.uow.payments.findByOrderId(orderId, {
      order: true,
      cashback: true,
    });

    if (!payment) {
      return null;
    }

    const paymentResponse = this.mapToPaymentResponse(payment);

    // L∆∞u v√†o cache 30 ph√∫t
    await redis.set(cacheKey, JSON.stringify(paymentResponse), 1800);

    return paymentResponse;
  }

  /**
   * L·∫•y danh s√°ch payments v·ªõi filter
   * @param options 
   * @returns 
   */
  async getPayments(
    options?: PaymentSearchFilters
  ): Promise<PaginatedResponse<PaymentResponse>> {
    const page = options?.page || 1;
    const limit = options?.limit || 10;

    // T·∫°o cache key
    const cacheKey = CacheUtil.paymentsList(page, limit);

    // Ki·ªÉm tra cache
    const cachedResult = await redis.get(cacheKey);
    if (cachedResult) {
      return JSON.parse(cachedResult);
    }

    const payments = await this.uow.payments.findMany({
      skip: (page - 1) * limit,
      take: limit,
      ...(options?.status && { status: options.status }),
      ...(options?.method && { method: options.method }),
      ...(options?.where && { where: options.where }),
    });

    const total = await this.uow.payments.count(options?.where);

    const result = {
      data: payments.map(this.mapToPaymentResponse),
      pagination: {
        total,
        totalPages: Math.ceil(total / limit),
        currentPage: page,
        limit,
        hasNext: (page + 1) * limit < total,
        hasPrev: page > 1,
      },
    };

    // L∆∞u v√†o cache 15 ph√∫t
    await redis.set(cacheKey, JSON.stringify(result), 900);

    return result;
  }

  /**
   * C·∫≠p nh·∫≠t tr·∫°ng th√°i payment
   * @param paymentId 
   * @param input 
   * @returns 
   */
  async updatePaymentStatus(
    paymentId: string,
    input: UpdatePaymentStatusInput
  ): Promise<PaymentResponse> {
    return this.uow.executeInTransaction(async (uow) => {
      const payment = await uow.payments.findById(paymentId, { order: true });
      if (!payment) {
        throw new NotFoundError('Thanh to√°n kh√¥ng t·ªìn t·∫°i');
      }

      // Validate status transition
      this.validateStatusTransition(payment.status, input.status);

      // C·∫≠p nh·∫≠t payment
      const updatedPayment = await uow.payments.updateStatus(
        paymentId,
        input.status,
        {
          transactionId: input.transactionId ?? '',
          gatewayResponse: input.gatewayResponse,
          ...(input.status === PaymentStatus.PAID && { paidAt: new Date() }),
          ...(input.status === PaymentStatus.FAILED && {
            failedAt: new Date(),
            failureReason: input.failureReason,
          }),
        }
      );

      // N·∫øu thanh to√°n th√†nh c√¥ng, c·∫≠p nh·∫≠t order v√† t·∫°o cashback
      if (input.status === PaymentStatus.PAID && payment.orderId) {
        // C·∫≠p nh·∫≠t order payment status
        await uow.orders.update(payment.orderId, {
          paymentStatus: PaymentStatus.PAID,
          paidAt: new Date(),
        });

        // TODO: T·∫°o cashback n·∫øu ƒë·ªß ƒëi·ªÅu ki·ªán
        // S·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi CashbackService
      }

      const result = await uow.payments.findById(paymentId, {
        order: true,
        cashback: true,
      });
      if (!result) {
        throw new NotFoundError('Thanh to√°n kh√¥ng t·ªìn t·∫°i');
      }

      // Invalidate cache
      await this.invalidatePaymentCache(paymentId, payment.orderId);

      return this.mapToPaymentResponse(result);
    });
  }

  /**
   * X·ª≠ l√Ω webhook t·ª´ payment gateway
   * @param webhookData 
   * @returns 
   */
  async handlePaymentWebhook(
    webhookData: PaymentWebhookData
  ): Promise<PaymentResponse> {
    return this.uow.executeInTransaction(async (uow) => {
      // T√¨m payment theo transactionId
      const payment = await uow.payments.findByTransactionId(
        webhookData.transactionId
      );

      if (!payment) {
        throw new NotFoundError(
          `Payment v·ªõi transaction ${webhookData.transactionId} kh√¥ng t·ªìn t·∫°i`
        );
      }

      // Verify signature (t√πy gateway)
      // this.verifyWebhookSignature(webhookData);

      // C·∫≠p nh·∫≠t payment status d·ª±a v√†o webhook
      let newStatus: PaymentStatus;
      switch (webhookData.status) {
        case 'success':
        case 'completed':
          newStatus = PaymentStatus.PAID;
          break;
        case 'failed':
        case 'error':
          newStatus = PaymentStatus.FAILED;
          break;
        default:
          newStatus = PaymentStatus.PENDING;
      }

      return this.updatePaymentStatus(payment.id, {
        status: newStatus,
        transactionId: webhookData.transactionId,
        gatewayResponse: webhookData.rawData,
        ...(newStatus === PaymentStatus.FAILED && {
          failureReason: webhookData.message,
        }),
      });
    });
  }

  /**
   * H·ªßy payment (ch·ªâ cho PENDING)
   * @param paymentId 
   * @param reason 
   * @returns 
   */
  async cancelPayment(
    paymentId: string,
    reason?: string
  ): Promise<PaymentResponse> {
    const payment = await this.uow.payments.findById(paymentId);
    if (!payment) {
      throw new NotFoundError('Thanh to√°n kh√¥ng t·ªìn t·∫°i');
    }

    if (payment.status !== PaymentStatus.PENDING) {
      throw new ValidationError('Ch·ªâ c√≥ th·ªÉ h·ªßy thanh to√°n ƒëang ch·ªù x·ª≠ l√Ω');
    }

    return this.updatePaymentStatus(paymentId, {
      status: PaymentStatus.FAILED,
      failureReason: reason || 'ƒê√£ h·ªßy thanh to√°n',
    });
  }

  /**
   * X·ª≠ l√Ω c√°c payment ƒë√£ h·∫øt h·∫°n
   * @returns s·ªë l∆∞·ª£ng payment ƒë√£ x·ª≠ l√Ω
   */
  async processExpiredPayments(): Promise<number> {
    const expiredPayments = await this.uow.payments.findExpiredPendingPayments();

    let processedCount = 0;
    for (const payment of expiredPayments) {
      try {
        await this.updatePaymentStatus(payment.id, {
          status: PaymentStatus.FAILED,
          failureReason: 'Thanh to√°n ƒë√£ h·∫øt h·∫°n',
        });
        processedCount++;
      } catch (error) {
        console.error(
          `Failed to process expired payment ${payment.id}:`,
          error
        );
      }
    }

    return processedCount;
  }

  /**
   * Th·ªëng k√™ doanh thu t·ª´ payments
   * @param filters 
   * @returns 
   */
  async getPaymentStatistics(filters?: {
    startDate?: Date;
    endDate?: Date;
    method?: PaymentMethod;
  }) {
    // Ki·ªÉm tra cache tr∆∞·ªõc
    const cacheKey = CacheUtil.paymentStatistics();
    const cachedStats = await redis.get(cacheKey);
    if (cachedStats) {
      return JSON.parse(cachedStats);
    }

    const where: any = {
      status: PaymentStatus.PAID,
      ...(filters?.startDate && {
        paidAt: { gte: filters.startDate },
      }),
      ...(filters?.endDate && {
        paidAt: { ...{ lte: filters.endDate } },
      }),
      ...(filters?.method && { method: filters.method }),
    };

    const [totalAmount, totalCount] = await Promise.all([
      this.uow.payments.sumAmount(where),
      this.uow.payments.count(where),
    ]);

    const stats = {
      totalAmount,
      totalCount,
      averageAmount: totalCount > 0 ? totalAmount / totalCount : 0,
    };

    // L∆∞u v√†o cache 1 gi·ªù
    await redis.set(cacheKey, JSON.stringify(stats), 3600);

    return stats;
  }

  //#region Private methods

  private validateStatusTransition(
    currentStatus: PaymentStatus,
    newStatus: PaymentStatus
  ): void {
    const validTransitions: Record<PaymentStatus, PaymentStatus[]> = {
      [PaymentStatus.PENDING]: [PaymentStatus.PAID, PaymentStatus.FAILED],
      [PaymentStatus.PAID]: [PaymentStatus.REFUNDED],
      [PaymentStatus.FAILED]: [], // kh√¥ng th·ªÉ chuy·ªÉn t·ª´ failed
      [PaymentStatus.REFUNDED]: [], // kh√¥ng th·ªÉ chuy·ªÉn t·ª´ refunded
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new ValidationError(
        `Kh√¥ng th·ªÉ chuy·ªÉn t·ª´ ${currentStatus} sang ${newStatus}`
      );
    }
  }

  private mapToPaymentResponse(payment: any): PaymentResponse {
    return {
      id: payment.id,
      orderId: payment.orderId,
      amount: Number(payment.amount),
      currency: payment.currency,
      method: payment.method,
      status: payment.status,
      transactionId: payment.transactionId,
      gatewayResponse: payment.gatewayResponse,
      paidAt: payment.paidAt,
      expiredAt: payment.expiredAt,
      failedAt: payment.failedAt,
      failureReason: payment.failureReason,
      note: payment.note,
      cashback: {
        id: payment.cashback.id,
        amount: Number(payment.cashback.amount),
        status: payment.cashback.status,
      },
      createdAt: payment.createdAt,
      updatedAt: payment.updatedAt,
    };
  }

  //#endregion

  // ==================== PRIVATE CACHE METHODS ====================
  /**
   * Invalidate cache li√™n quan ƒë·∫øn payment
   */
  private async invalidatePaymentCache(
    paymentId?: string,
    orderId?: string
  ): Promise<void> {
    try {
      if (paymentId) {
        await redis.del(CacheUtil.paymentById(paymentId));
      }

      if (orderId) {
        await redis.del(CacheUtil.paymentByOrderId(orderId));
      }

      // X√≥a payment list caches
      for (let page = 1; page <= 50; page++) {
        await redis.del(CacheUtil.paymentsList(page, 10));
        await redis.del(CacheUtil.paymentsList(page, 20));
        await redis.del(CacheUtil.paymentsList(page, 50));
      }

      // X√≥a payment statistics
      await redis.del(CacheUtil.paymentStatistics());
    } catch (error) {
      console.error('Error invalidating payment cache:', error);
    }
  }
}